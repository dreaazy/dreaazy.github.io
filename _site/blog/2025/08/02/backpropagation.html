<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Backpropagation</title>
<meta name="description" content="The backpropagation is main algorithm used for training neural network via gradient descend. To understand deeply the topics in this essay require a basic knowledge of calculus and linear algebra.">


  <meta name="author" content="Simone Piccinini">
  
  <meta property="article:author" content="Simone Piccinini">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="">
<meta property="og:title" content="Backpropagation">
<meta property="og:url" content="http://localhost:4000/blog/2025/08/02/backpropagation.html">


  <meta property="og:description" content="The backpropagation is main algorithm used for training neural network via gradient descend. To understand deeply the topics in this essay require a basic knowledge of calculus and linear algebra.">







  <meta property="article:published_time" content="2025-08-02T00:00:00+02:00">






<link rel="canonical" href="http://localhost:4000/blog/2025/08/02/backpropagation.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/blog/"
                
                
              >Blog</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li><li class="masthead__menu-item">
              <a
                href="https://github.com/dreaazy"
                
                
              >GitHub</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/avatar.png" alt="Simone Piccinini" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Simone Piccinini</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Software Engineer, and Machine Learning Enthusiast.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Padua, Italy</span>
        </li>
      

      

      

      
        <li>
          <a href="mailto:piccinini.simone2005@gmail.com" rel="me" class="u-email">
            <meta itemprop="email" content="piccinini.simone2005@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/simone-piccinini-b32966261" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span>
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/dreaazy" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      
      
        <li>
          
            <span class="nav__sub-title">Archives</span>
          

          
          <ul>
            
              <li><a href="/categories/">Category</a></li>
            
              <li><a href="/tags/">Tag</a></li>
            
          </ul>
          
        </li>
      
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Backpropagation">
    <meta itemprop="description" content="The backpropagation is main algorithm used for training neural network via gradient descend.To understand deeply the topics in this essay require a basic knowledge of calculus and linear algebra.">
    <meta itemprop="datePublished" content="2025-08-02T00:00:00+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/blog/2025/08/02/backpropagation.html" itemprop="url">Backpropagation
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-08-02T00:00:00+02:00">August 2, 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          36 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>The backpropagation is main algorithm used for training neural network via gradient descend.
To understand deeply the topics in this essay require a basic knowledge of calculus and linear algebra.</p>

<p>What does it mean training a network so that it could learn and generalize to solve our problem?
Training a network means adjusting his weight and biases according on how the model perform better for our current problem.
To achieve this result we aim to reduce the function of loss.
This is what gradient descend stands for.
Finding the local minimum of our function of loss to minimize the error.
So the gradient descend is just a routine of optimization of our model.</p>

<p>Backpropagation can make training a network with gradient descend as much as ten million times faster, relative to a naive implementation.</p>

<p>Backpropagation is mainly used for training neural networks by efficiently computing gradients needed for optimization. However, its underlying principle of reverse-mode automatic differentiation has found applications in other fields such as scientific computing, control theory, computer graphics, and engineering design. In these areas, backpropagation helps optimize complex systems by enabling fast and accurate calculation of sensitivities and parameter gradients.</p>

<p>In this essay I’m going to use sources like the excellent free book on neural network written by Micheal Nilsen, you will find all the resources at the end of the essay.</p>

<h2 id="computational-graph">Computational graph</h2>

<p>Computational graphs are very useful in computer science, they allow you to track and compute complex mathematical expressions by breaking them down into a sequence of simple operations. Each node in a computational graph represents an operation (like addition, multiplication, or a more complex function), and each edge carries data, often in the form of tensors or scalars.</p>

<p>For example consider the expression:
\(e = (a+b) * (b+1)\)</p>

<p>We can add a intermediate step:
\(c = a+b\) and \(d = b+1\).
And get the result \(e = c * d\).
<img src="/assets/Backpropagation-media/95d9ad30fd5932138b603f7a38133d73835120aa.svg" class="wikilink" alt="./resources/cg_1.svg" style="width: 100%; max-width: 600px;" /></p>

<p>To evaluate the expression we can set the input variable to certain values, for example a=2, b=1.</p>

<p><img src="/assets/Backpropagation-media/0b4c50deb00024de16f8bf39938eef77600c9d48.svg" class="wikilink" alt="./resources/cg_2.svg" style="width: 100%; max-width: 600px;" /></p>

<p>To know how \(e\) varies changes \(a\) or \(b\) we have to compute partial derivatives in the computational graph.
For evaluating this graph we need the sum rule and the product rule.</p>

\[\frac{\partial }{\partial a}(a+b) = \frac{\partial a}{\partial a} + \frac{\partial b}{\partial a} = 1\]

\[\frac{\partial }{\partial u}(uv) = \frac{\partial u}{\partial u}\cdot v+\frac{\partial v}{\partial u}\cdot u\]

<p><img src="/assets/Backpropagation-media/0d06683576b3c735410bd8341dc24b0da52ca10b.svg" class="wikilink" alt="./resources/cg_3.svg" style="width: 100%; max-width: 600px;" />
The key idea to understand the efficiency of backpropagation and follow the next part of the essay is to grasp the difference between <strong>forward mode differentiation</strong> and <strong>backward mode differentiation</strong>.
<strong>Forward-mode differentiation</strong> starts at an input to the graph and moves towards the end. At every node, it sums all the paths feeding in. Each of those paths represents one way in which the input affects that node. By <strong>adding them up</strong>, we get the total way in which the node is affected by the input, it’s derivative.
<strong>Reverse-mode differentiation</strong>, on the other hand, starts at an output of the graph and moves towards the beginning. At each node, <strong>it merges all paths</strong> which originated at that node.</p>

<p>Let’s take for example we have a function of three variable:</p>

\[f(x,y,z) = z\]

<p>The total differential for a function of three variable is:</p>

\[df = \frac{\partial f}{\partial x}dx + \frac{\partial f}{\partial y}dy+\frac{\partial f}{\partial z}\]

<p>If in turn x,y,z depends on a variable t, we can apply the <strong>chain rule</strong> and the total differential becomes:</p>

\[\frac{\partial f}{\partial t} = \frac{\partial f}{\partial x}\cdot\frac{\partial x}{\partial t} + \frac{\partial f}{\partial y}\cdot\frac{\partial y}{\partial t}+\frac{\partial f}{\partial z}\cdot\frac{\partial z}{\partial t}\]

<p>To understand how \(a\) changes according to nodes that are not directly connected to it we just applying the chain rule.
Let’s analyze how \(e\) changes if \(a\) changes:</p>

\[\frac{\partial e}{\partial a} = \frac{\partial e}{\partial c}\cdot \frac{\partial c}{\partial a} = 2\cdot 1=2\]

<p>Let’s analyze how \(e\) changes if \(b\) changes, in this case <strong>we have to sum the contribution for multiple paths.</strong></p>

\[\frac{\partial e}{\partial b} = \frac{\partial e}{\partial c}\cdot \frac{\partial c}{\partial b} + \frac{\partial e}{\partial d}\cdot \frac{\partial d}{\partial b}  = 2 \cdot 1 + 3 \cdot 1 = 5\]

<p>Now let’s make a concrete example using the previous expression.<br />
Understanding this will help you appreciate <strong>why backpropagation is so efficient</strong> when training neural networks.</p>

<p>To see how the output \(e\) changes when the input $b$ changes, we could use a <strong>forward-mode differentiation</strong> approach:<br />
We would start from the node where \(b=1\) and <strong>follow all paths forward</strong> through the graph, <strong>summing the contributions</strong> that lead to \(e\).</p>

<p>However, we would have to repeat this process separately for <strong>each input</strong> (like a, b, etc.) — which can be slow when there are many inputs, as in neural networks.</p>

<figure>

<img src="/assets/Backpropagation-media/8bfdf7f5612baeb02bbcea9a31d0a465c334cf53.svg" alt="Description" style="width: 100%; max-width: 600px;" />
<figcaption>

Figure 1: Feedforward differentiation starting from the node b.
</figcaption>

</figure>

<p>With this approach we would have to do the same thing for the \(a\) node, and then sum up the contributions of all the derivatives of all the input nodes.</p>

<p>Using a <strong>backward differentiation</strong> approach (reverse-mode), we start from the final output and propagate gradients <strong>backward</strong> through the graph.<br />
This allows us to compute the <strong>partial derivatives of the output with respect to all input variables in a single backward pass</strong>, thanks to <strong>factoring and reusing common paths</strong> via the chain rule.</p>
<figure>

<img src="/assets/Backpropagation-media/1b13aa38787f99388b86100a809639240e9fd24a.svg" alt="Description" style="width: 100%; max-width: 600px;" />
<figcaption>

Figure 2: Backward differentiation starting from the node e we are able to get the derivatives of all the input nodes.
</figcaption>

</figure>

<p>This example show how if we have a function with multiple inputs and few outputs a function like:
\(\large
f:\mathbb{R}^n\to \mathbb{R}\)</p>

<p>Is <strong>much more efficient</strong> using backward differentiation to understand how the output changes of the input changes.
If for example we have 1,000,000 inputs, forward differentiation would require 1,000,000 passes through the network, while backpropagation differentiation would require just 2 passes through the network (<strong>one for evaluating the expression at each node and one for calculating the derivatives</strong>).
So <strong>reverse-mode is ~500,000× faster</strong> in practice for this case!</p>

<h2 id="structure-of-a-neural-network-and-notation">Structure of a neural network and notation</h2>

<p>This is a simple schema of a neural network, it’s composed of one layer of input, one hidden layer and one output layer.
<img src="/assets/Backpropagation-media/simplenet.svg" class="wikilink" alt="simplenet.svg" style="width: 100%; max-width: 600px;" /></p>

<h3 id="notation">notation</h3>

<p>Simple photo that follows show the notation on neurons connected between each other.
Two neurons are connected by a weight, the value of a neuron is given by \(a_{j}^l\) where l represents the current layer while \(j\) stands for which neuron in the layer we are referring to.
Each neuron has a bias (\(b_{t}^l\)), the meaning of the notation if the same as the previous.</p>

<figure style="text-align: center; margin: 1em auto;">
  <img src="/assets/Backpropagation-media/notation.svg" alt="notation.svg" style="width: 100%; max-width: 600px;" />
  <figcaption>notation.svg</figcaption>
</figure>

<p>In a neural network each neuron is connected with all the other neurons in the next layer, and the strength of each connection is characterized by a <strong>weight</strong>. In addition to these weighted connections, each neuron also has a <strong>bias</strong> term, which acts like an adjustable constant input that allows the neuron to shift its activation function, helping the network better fit the data by enabling the output to be offset independently of the inputs. The neuron computes a weighted sum of its inputs, adds the bias, and then passes the result through an <strong>activation function</strong> — a nonlinear transformation such as ReLU, sigmoid, or tanh. This nonlinearity is crucial, as it allows the network to learn and approximate complex, non-linear mappings between inputs and outputs. Without activation functions, no matter how many layers the network has, it would behave like a linear model.</p>

<p>This photos shows the steps to evaluate the level of activation of one neuron, \(z_{j}^1\) is an intermediate step, while \(a_{j}^1\) is the final level of activation.</p>

<p><img src="/assets/Backpropagation-media/activation.svg" class="wikilink" alt="activation.svg" style="width: 100%; max-width: 600px; " /></p>

<p>Each neuron of the \(\ell\) layer takes as input the activation level of all the other neurons in the \(\ell-1\)  layer of the network.
We can calculate the activation of the neuron \(j\) in the layer \(\ell\) as:</p>

\[\large
a_{j}^{\ell} = \sigma \left(\sum_{k} w_{jk}^{\ell} a_{k}^{\ell -1} + b_{j}^{\ell}\right) 

\tag{1}\]

<p>I will be much easier to manage if we would translate this in vector form, it’s simple to show that the last expression is equal to:</p>

\[\large
a^{\ell}=\sigma\left( W^{\ell}a^{\ell-1} + b^{\ell} \right)\]

<p>And our intermediate step will be:</p>

\[\large z^{\ell} = W^{\ell}a^{\ell-1} + b^{\ell}\]

<h2 id="cost-function">Cost function</h2>

<p>When training a neural network, we begin by defining a <strong>loss function</strong> \(l(h(x),y)\) that quantifies how far the model’s prediction \(h(x)\) is from the true output \(y\) for a <strong>single data point</strong>. This single-point loss is exactly what we use to compute gradients via <strong>backpropagation</strong>, updating the model’s weights to reduce the error. However, in practice, we don’t just have one example — we are given a dataset of samples \({(X_{1},Y_{2}),…,(X_{n},Yn)}\), which are drawn from some <strong>unknown distribution</strong> \(P(x,y)\). Our goal would ideally be to minimize the <strong>expected loss</strong> over this distribution:</p>

\[\large
\mathbb{E}_{(x,y) \sim P} \left[ \ell(h(x), y) \right] = \int \ell(h(x),y) dP(x,y)\]

<p>But since $P(x,y)$ is unknown, we cannot compute this expectation directly. Instead, we approximate it using the <strong>empirical average</strong> over our dataset:</p>

\[\large
\hat{C} = \frac{1}{n} \sum_{x} \ell(h(X_{i}),Y_{i})

\tag{2}\]

<p>This empirical loss is what we minimize in practice. And since it’s a sum of differentiable single-sample losses, we can still apply <strong>backpropagation</strong>, either over the entire sum (in batch gradient descent) or over small subsets (in stochastic or mini-batch gradient descent). Thus, the justification for using backpropagation over many samples stems from the fact that the empirical loss is an <strong>estimator of the expected loss</strong> — and the best tool we have for reducing it with gradient-based methods.</p>

<p>This cost function takes as input <strong>all the weights and biases</strong> of the network and measures <strong>how far off the network’s predictions are</strong> compared to the actual target outputs.</p>

<p>The choice on which cost function to choose varies according to the problem we are trying to solve.
For this essay I’m going to take in consideration the simplest cost function that is the <strong>Mean squared error</strong>:</p>

\[\large
C(w,b)=\frac{1}{n}\sum_{x} ||y(x)− a^L(x)||^2

\tag{3}\]

<p>Where \(y(x)\) is the desired output, \(a\) is the output we can, it obviously depends on the weights and biases of the network, while \(x\) stands for the training samples.</p>

<p>Indeed the cost for a simple training example is:</p>

\[\large
C_{x} = \frac{1}{2} ||y-a^L||^2

\tag{4}\]

<p>What backpropagation allow us to do is to calculate \(\large \frac{\partial C_{X}}{\partial w}\) and \(\large \frac{\partial C_{x}}{\partial b}\) and then finding \(\large \frac{\partial C}{\partial w}\) and \(\large \frac{\partial C}{\partial b}\) averaging over the training samples.</p>

<p>I said earlier that the cost function take as input all the weight and biases of the network, I need to precise better that.
The cost function take as input <strong>the last layer of the network</strong>, or also called the <strong>“prediction</strong>” of the network, the prediction depends on all the weights and biases of the network.
The cost function measures <strong>how close or far is the prediction compared to the actual result</strong>, backpropagation through gradient descend, is an algorithm to make this prediction closes as possible.
<img src="/assets/Backpropagation-media/cf_1.svg" class="wikilink" alt="cf_1.svg" style="width: 100%; max-width: 600px;" /></p>

<h2 id="backpropagation-derivation">Backpropagation derivation</h2>

<p>Once understood the problem we are trying to solve, let’s try to address the problem in a more mathematical way.
The heart of backpropagation is understand how the cost function varies, if the matrix of weights of the first layer varies.
Or in a mathematical way:</p>

\[\large
\frac{\partial C \left( a^L\left( a^{L-1}\right) \dots\left( a^l\left(w^l \right)\right)\right)}{\partial w^l}\]

<ul>
  <li>
    <p>\(C\) is a <strong>scalar loss function</strong> (like MSE or cross-entropy)</p>
  </li>
  <li>
    <p>\(w^l \in \mathbb{R}^{n\times m}\) is the <strong>weight matrix</strong> for layer \(l\)</p>
  </li>
  <li>
    <p>The output \(C\) depends on the activations, which depend on the weights from <strong>all previous layers</strong>, including \(w^l\)</p>
    <h5 id="what-we-want-to-do-is-to-apply-the-chain-rule-layer-by-layer-through-the-computational-graph">What we want to do is to apply the chain rule layer by layer through the computational graph.</h5>
  </li>
</ul>

<p>We have a scalar function \(C\) that depends on a vector \(a^L\) <strong>that depends on a vector that depends on a vector</strong>…. so on until we have a vector that depends on a matrix \(w^l\).</p>

<p>Since the cost \(C\) is a scalar, and the weights \(w^l\) are a matrix, we’re computing the <strong>derivative of a scalar function with respect to a matrix</strong>.</p>

<p>But this scalar depends on a composition of many functions — vectors and matrices interacting across layers. So to compute this derivative, we’ll need to use:</p>

<ul>
  <li>
    <p>Derivative of a scalar with respect to vector (gradient)</p>
  </li>
  <li>
    <p>Derivative of a scalar with respect to matrix</p>
  </li>
  <li>
    <p>Derivative of a vector with respect to a vector (Jacobian)</p>
  </li>
  <li>
    <p>Chain rule for matrix calculus</p>
  </li>
</ul>

<h3 id="derivative-of-a-scalar-function-with-respect-to-a-vector">Derivative of a scalar function with respect to a vector</h3>

<p>Let \(C:\mathbb{R}^n\to \mathbb{R}\), with \(v=(x_1,x_{2},\dots,x_{n})\).</p>

\[\frac{\partial C}{\partial v} = \nabla C =\begin{pmatrix}
\frac{\partial C}{\partial x_{1}} \\
\frac{\partial C}{\partial x_{2}} \\
\vdots \\
\frac{\partial C}{\partial x_{n}}
\end{pmatrix}\]

<p>Example: suppose \(v=a^L\) , \(C=C(a^L)\), then:</p>

\[\frac{\partial C}{\partial a^L} = \begin{pmatrix}
\frac{\partial C}{\partial a_{1}^L} \\
\frac{\partial C}{\partial a_{2}^L} \\
\vdots \\
\frac{\partial C}{\partial a_{n}^L}
\end{pmatrix}\]

<p>So: 
\(\large \frac{\partial C}{\partial a^L} = \nabla_{a_{L}} C\in \mathbb{R}^{n\times1}\)</p>

<p>The derivative of a scalar function with respect to a vector is just the gradient of that function, <strong>this tells us how much the cost changes when each component of the vector \(a^L\) changes</strong>.</p>

<h3 id="vector-function-of-a-vector-variable">Vector function of a vector variable</h3>

<p>Let \(f:\mathbb{R}^n\to \mathbb{R}^m\),\(x=(x_{1},x_{2}\dots,x_{n})\), then:</p>

\[f(x) = \begin{pmatrix}
f_{1}(x) \\
f_{2}(x) \\
\vdots \\
f_{m}(x)


\end{pmatrix}\]

<p>Each \(f_{i}\) is a scalar function of the same vector \(x \in \mathbb{R}^n\).
Then the derivative is the <strong>Jacobian matrix</strong>:</p>

\[\frac{\partial f}{\partial x} = J=
\begin{pmatrix}
\frac{\partial f_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_1}{\partial x_n} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_m}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_n}
\end{pmatrix}\]

<p>This generalizes the gradient it tells <strong>how each component of the output vector changes according to every input component</strong>.
Each row is the gradient of one component function \(f_{i}(x)\). So the Jacobian is a stack of gradients.</p>

<h3 id="derivative-of-a-scalar-function-with-respect-to-a-matrix">Derivative of a scalar function with respect to a matrix</h3>

\[\large 
f:\mathbb{R}^{n \times m}\to \mathbb{R}\]

<p>So \(f\) is a scalar function of a matrix.
The derivative is defined as:</p>

\[\frac{\partial f}{\partial W}
= \begin{pmatrix}
\frac{\partial f}{\partial w_{11}} &amp; \cdots &amp; \frac{\partial f}{\partial w_{1m}} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f}{\partial w_{n1}} &amp; \cdots &amp; \frac{\partial f}{\partial w_{nm}} \\
\end{pmatrix}
\in \mathbb{R}^{n \times m}\]

<p>We differentiate the scalar function with respect to each component of the matrix — and the result is again a matrix.</p>

<p>Turning back to our final objective, that is to compute \(\large \frac{\partial C}{\partial w^l}\).
This falls under the case of a <strong>scalar function of a matrix</strong>, and produces a matrix of partial derivatives.
However, to compute it via the chain rule, we often encounter intermediate expressions such as the derivative of a <strong>vector with respect to a matrix</strong>.</p>
<h3 id="this-brings-us-to-study-vector-valued-functions-of-matrix-variables">This brings us to study vector-valued functions of matrix variables:</h3>

\[\large f:\mathbb{R}^{n\times m}\to \mathbb{R}^k\]

<p>This function takes as input a matrix and gives out a vector, so the function would look something like:</p>

\[f(W)=\begin{pmatrix}
f_{1}(W) \\
f_{2}(W) \\
\vdots \\
f_{k}(W)
\end{pmatrix}\]

<p>What is \(\huge \frac{\partial C}{\partial W}\)?</p>

<p>Each component function $f_{i}(W)$ is a scalar function of the matrix $W$. So we can take its derivative just like before:
\(\large 
\frac{\partial f_{i}}{\partial W}\in R^{n\times m}\)</p>

<p>Now since we have $k$ of them we just stuck these matrixes the one after the other.
That gives us a cube-like object with shape:
\(\large 
\frac{\partial f}{\partial W} \in \mathbb{R}^{k \times n \times m}\)</p>

<p><strong>This is a rank-3 tensor.</strong>
This tensor tells us how each output component $f_{i}$ changes with each element $w_{jk}$​ of the input matrix.</p>

<p>In our case the function $f$ corresponds to $a^l$, and the components of $a^l$ are the individual activations of $a_{i}^l$, which correspond to the different $f_{i}$ .</p>

<p>This is an example of matrixes for the first 3 layers of the network: layer 1, layer 2 and layer 3.</p>

<figure>
<img src="/assets/Backpropagation-media/64b73722444b2241bacbd82e7e9349dce2b896f0.svg" class="wikilink" alt="./resources/tensor.svg" />
<figcaption aria-hidden="true">./resources/tensor.svg</figcaption>
</figure>

<p><em>Figure 2: In our case, the function $f$ corresponds to $a^l$, and the components of $a^l$ are the individual activations $a^l_i$, which correspond to the different $f_i$.</em></p>

<p>We understood how to differentiate with respect to vectors an matrixes, now we need to find the namesake of the chainrule but for vectors.
So we need to evaluate something like:</p>

\[\large \frac{\partial C \left(y(x) \right)}{\partial x}\]

<p>Where:</p>
<ul>
  <li>$C$ is a scalar function</li>
  <li>$\large y:\mathbb{R}^n\to \mathbb{R}^m$ is a vector valued function</li>
  <li>and $\large x \in \mathbb{R}^n$
The composition $C(y(x))$ is still a scalar function — it maps $\large x∈\mathbb{R}^n$ to a real number via $\large y$.</li>
</ul>

<p>As we saw before, we are taking the derivative of a scalar function with respect to a vector, and that is just the gradient.</p>

\[\large \frac{\partial C \left(y(x) \right)}{\partial x} =\nabla_{c} C=\begin{pmatrix}
\frac{\partial C}{\partial x_{1}} \\
\frac{\partial C}{\partial x_{2}} \\
\vdots \\
\frac{\partial C}{\partial x_{n}}
\end{pmatrix}\]

<p>But now, we can go a step further and express how $\large C$ depends on $\large x$ <strong>through</strong> $\large y(x)$.</p>

\[\large C=C(y_{1}(x),y_{2}(x),\dots,y_{m}(x))\]

<p>So what we are dealing with is a composition of functions, so we use the chain rule for multivariable calculus we have seen when we were dealing with the computational graphs:</p>

\[\large \frac{\partial C}{\partial x_{j}}=\sum_{i=1}^m \frac{\partial C}{\partial y_{i}} \cdot\frac{\partial y_{i}}{\partial x_{j}}\]

<p>This tells us: to compute how $C$ changes as we vary $\large x_{j}$​, we look at how each $\large y_{i}$​ changes with $x_{j}$​, weighted by how sensitive $\large C$ is to $\large y_{i}$​.</p>

<p>$\large x$ is a vector of $\large n$ components, so if we stack all these pieces of chain rule together we get:</p>

\[\large \nabla_{x} C=\begin{pmatrix}
\sum_{i=1}^m \frac{\partial C}{\partial y_{i}} \cdot\frac{\partial y_{i}}{\partial x_{1}} \\
\sum_{i=1}^m \frac{\partial C}{\partial y_{i}} \cdot\frac{\partial y_{i}}{\partial x_{2}} \\
\vdots \\
\sum_{i=1}^m \frac{\partial C}{\partial y_{i}} \cdot\frac{\partial y_{i}}{\partial x_{n}}
\end{pmatrix}\]

<h4 id="matrix-form-vector-chain-rule">Matrix Form: Vector Chain Rule</h4>

<p>Rather than writing all those sums explicitly, we can express this <strong>compactly using matrix multiplication</strong>.</p>

<p>Let’s define:</p>

<ul>
  <li>The <strong>Jacobian matrix</strong> $\large \frac{\partial y}{\partial x}\in \mathbb{R}^{m \times n}$ , whose $(i,j)-th$ entry is $\large \frac{\partial y_{i}}{\partial x_{j}}$</li>
  <li>The <strong>gradient of $\large C$ with respect to $\large y$</strong>, $\large \nabla_{y} C =\mathbb{R}^m$, whose $i$ components is $\large \frac{\partial C}{\partial y_{i}}$
Then the full gradient is:</li>
</ul>

\[\large \nabla_{c} C = \left(\frac{\partial y}{\partial x}\right)^{\top} \cdot \nabla_{y} C

\tag{5}\]

<p>That is the Chain rule for vector-valued function.</p>

<h2 id="chain-rule-with-matrix-valued-variables">Chain Rule with Matrix-Valued Variables</h2>

<p>We now want to compute the derivative of a scalar function composed with a function of a matrix:</p>

\[\large \frac{\partial C(Y(W))}{\partial W}\]

<hr />

<p>Differentiate a scalar with respect to a matrix:
\(\large
\frac{\partial C}{\partial W} =
\begin{pmatrix}
\frac{\partial C}{\partial w_{11}} &amp; \frac{\partial C}{\partial w_{12}} &amp; \cdots &amp; \frac{\partial C}{\partial w_{1n}} \\
\frac{\partial C}{\partial w_{21}} &amp; \frac{\partial C}{\partial w_{22}} &amp; \cdots &amp; \frac{\partial C}{\partial w_{2n}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial C}{\partial w_{m1}} &amp; \frac{\partial C}{\partial w_{m2}} &amp; \cdots &amp; \frac{\partial C}{\partial w_{mn}} \\
\end{pmatrix}\)</p>

<p>Our case the scalar C depends on a vector $\large y$, and that vector depends on the matrix $\large W$</p>

<ul>
  <li>$\large C: \mathbb{R}^{m} \to \mathbb{R}$ is a scalar function</li>
  <li>$\large  y: \mathbb{R}^{k \times n} \to \mathbb{R}^{m}$ is a vector-valued function</li>
  <li>$\large  W \in \mathbb{R}^{k \times n}$ is a matrix input</li>
</ul>

<hr />

<p>In our case the scalar function $\large C$ Depends on a vector $\large y$ and the vector depends on a matrix $\large W$.</p>

<p>This leads us to the composition</p>

\[\large  C\left(y\left(W\right)\right)\]

<p>With $\large y$ with the form of:</p>

\[\large y=\begin{pmatrix}
y_{1}(W) \\
y_{2}(W) \\
\vdots \\
y_{k}(W)
\end{pmatrix}\]

<p>Now we have to use the matrix definition looking at the components of the matrix $\large W$:</p>

\[\large \left[ \frac{\partial C\left(y(W)\right)}{\partial W}\right]_{jk} = \frac{\partial C\left(y(W)\right)}{\partial w_{jk}}\]

<p>How $\large C$ depends on $\large w_{ij}$? It depends on $\large y$ that depends on $\large W$. So let’s apply the chain rule but for scalars.</p>

\[\large \frac{\partial C(y(W))}{\partial w_{jk}} = \sum_{i=1}^m \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{jk}}\]

<p>Now we can put it back into the full matrix:</p>

\[\large \frac{\partial C(y(W))}{\partial W} =
\begin{pmatrix}
\sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{11}} &amp; \cdots &amp; \sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{1n}} \\
\sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{21}} &amp; \cdots &amp; \sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{2n}} \\
\vdots &amp; \ddots &amp; \vdots \\
\sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{m1}} &amp; \cdots &amp; \sum_i \frac{\partial C}{\partial y_i} \cdot \frac{\partial y_i}{\partial w_{mn}} \\
\end{pmatrix}\]

<p>Each entry in this matrix is a sum of scalar-by-scalar products. We just applied the scalar chain rule to each component and it’s all there in one matrix.</p>

<h4 id="lets-simplify-the-notation">Let’s simplify the notation.</h4>

<ul>
  <li>$\large \frac{\partial y}{\partial W}$ is a tensor because it’s a vector with respect to a matrix.</li>
  <li>
    <p>$\large \frac{\partial C}{\partial y}$ it’s a vector
So we can write what we wrote as:</p>

\[\large \frac{\partial C(y(W))}{\partial W} = \sum_{i=1}^k \frac{\partial C}{\partial y_{i}} \cdot \frac{\partial y_{i}}{\partial W}\]

    <h4 id="using-tensor-contraction">Using Tensor contraction.</h4>
    <p>To simplify again our notation to scale it better on our neural network we need to use a tensor contraction.
A <strong>tensor contraction</strong> is an operation on a tensor that arises from the canonical pairing of a vector space and its dual.
When we “contract” over an axis, we’re summing along that dimension reducing its size.</p>
  </li>
</ul>

<p>So the final expression is:</p>

\[\large \frac{\partial C}{\partial W} = \sum_{i=1}^k \frac{\partial C}{\partial y_{i}} \cdot \frac{\partial y_{i}}{\partial W} \to\large \frac{\partial C}{\partial W} =  \frac{\partial y}{\partial W} \overset{i}{\cdot} \frac{C}{\partial y}

\tag{6}\]

<p>That’s how we simplify the chain rule when the variable is a matrix and the intermediate function is vector-valued.</p>

<h1 id="backpropagation-algorithm">Backpropagation algorithm</h1>

<p>Our main goal is to compute:</p>

\[\large \frac{\partial C \left( a^L\left( a^{L-1}\right) \dots\left( a^l\left(w^l \right)\right)\right)}{\partial w^l}

\tag{7}\]

<p>We are taking the derivative with respect to a matrix, but this scalar depends on a vector, that depends on a vector that depends on a vector and so on until it depends on the matrix $\large w^l$.</p>

<p>We start from the outermost layer, the layer linked with the matrix $\large w^l$ and we compute the tensor contraction:</p>

\[\large \frac{\partial C}{\partial W} =  \frac{\partial a^l}{\partial w^l} \overset{i}{\cdot} \frac{C}{\partial a^l}

\tag{8}\]

<p>But the vector $\large a^l$ depends on the vector $\large a^{l+1}$ and so on until the last layer $a^L$, to compute how each layer change each other we use the chain rule for vectors we found earlier:</p>

\[\large \frac{\partial C}{\partial a^l} = \left(\frac{\partial a^{l+1}}{\partial a^l}\right)^{\top} \cdot \frac{\partial C}{\partial a^{l+1}} 

\tag{9}\]

<p>And this is true for every layer:</p>

\[\large \frac{\partial C}{\partial a^{l+1}} = \left(\frac{\partial a^{l+2}}{\partial a^{l+1}}\right)^{\top} \cdot \frac{\partial C}{\partial a^{l+2}}\]

<p>And that is the recursive hear of backpropagation until the last layer $\large a^L$.</p>

<h3 id="error-backpropagation-signal">Error backpropagation signal</h3>

<p>Some sources define the error signal as:</p>

\[\large
\delta^l := \frac{\partial C}{\partial a^l}\]

<p>This can be used recursively:</p>

\[\large \frac{\partial C}{\partial a^l} = \left(\frac{\partial a^{l+1}}{\partial a^l}\right)^{\top} \cdot \frac{\partial C}{\partial a^{l+1}}  \to \delta^l= \left(\frac{\partial a^{l+1}}{\partial a^l}\right)^{\top} \cdot \delta^{l+1}\]

<p>However, in standard backpropagation, the error is usually defined as:
\(\large
\delta^l := \frac{\partial C}{\partial z^l}\)</p>

<p>The reason for the last definition is the most straight forward:</p>

<p>If we are for example in the neuron $\large j^{th}$ in the layer one. If we make a little change to the weighed input of the neuron $\large z_{j}^1$ adding the quantity $\large \Delta z_{j}^1$, then the activation input instead of outputting $\large \sigma(z_{j}^1)$ it will output $\large \sigma(z_{j}^1 + \Delta z_{j}^1 )$.
This change propagates through all the network and finally change the cost function of a quantity:</p>

\[\frac{\partial C}{\partial z_{j}^1}\cdot\Delta z_{j}^1\]

<p>If we want to try to minimize the cost function, we can try to chose the quantity $\large \Delta z_{j}^1$ so that makes the cost smaller.
If the quantity $\large \frac{\partial C}{\partial z_{j}^1}$ is close to zero then there is little to change, indeed if the quantity $\large \frac{\partial C}{\partial z_{j}^1}$ is big we can chose the quantity $\large \Delta z_{j}^1$ of the opposite sign to try to minimize the cost.</p>

<p>In this heuristic sense, this quantity $\large \frac{\partial C}{\partial z_{j}^1}$ is the measure of the error of the neuron $j^{th}$ in the layer 1.</p>

\[\large \delta_{j}^1=\frac{\partial C}{\partial z_{j}^1}\]

<h2 id="why-both-definitions-can-coexist">Why both definitions can coexist</h2>

<p>There is no contradiction between defining the error as $\large \frac{\partial C}{\partial a^l}$ or $\large \frac{\partial C}{\partial z^l}$, because they are directly related through the chain rule.
Since $\large a^l = \sigma(z^l)$, we apply the chain rule:</p>

\[\large
\frac{\partial C}{\partial z^l} = \frac{\partial C}{\partial a^l} \cdot \frac{\partial a^l}{\partial z^l}\]

<p>Because $\large \sigma$ is applied elementwise, this becomes an elementwise (Hadamard) product:</p>

\[\large
\frac{\partial C}{\partial z^l} = \frac{\partial C}{\partial a^l} \odot \sigma'(z^l)\]

<p>That is,</p>

\[\large
\delta^l = \tilde{\delta}^l \odot \sigma'(z^l)\]

<p>where</p>

\[\large
\tilde{\delta}^l := \frac{\partial C}{\partial a^l}\]

<p>So depending on the context, one may define and propagate $\large \tilde{\delta}^l$ (via the recursive expression), and then obtain the standard error $\large \delta^l$ by applying the derivative of the activation. They are just two steps in the same computation, not conflicting definitions.</p>

<p>This is the key equation for backpropagation that links the error of one layer to the layer of the next one.</p>

\[\Large \delta^l= \left(\frac{\partial a^{l+1}}{\partial a^l}\right)^{\top} \cdot \delta^{l+1}

\tag{11}\]

<p>Since we are interested in finding:</p>

\[\large \frac{\partial C}{\partial w^l} \text{ for all layers  }l\]

<p>Once we know the vector $\large \delta^l$ we can compute the weight gradient using a tensor contraction (using equation 8).</p>

\[\large 
\frac{\partial C}{\partial w^l} =  \frac{\partial a^l}{\partial w^l} \overset{i}{\cdot} \delta^l 
\tag{12}\]

<p>Before jumping to the algorithm itself and the implementation though code, I think is due to spend at least a little time explaining how the gradient descend work. How exactly finding all these derivative and stuff how actually is going to make our neural network learn something?</p>

<h2 id="gradient-descend">Gradient descend</h2>

<p><strong>The gradient is a vector that points in the direction of the greatest rate of increase of a scalar field.</strong></p>

<p>The gradient is calculable only of a scalar-valued differentiable function.</p>

<p>So the gradient is defined only for functions that take a $n-dimention$ vector and gives as output a scalar.</p>

\[\large
f:\mathbb{R}^n\to\mathbb{R}\]

<p>So you can use gradients only with scalar fields.</p>

<p>We can define the gradient of a function $f(r)$ as:</p>

\[\large df = \nabla f dr\]

<p>What is formula is saying is how much the function will change according to the displacement $dr$.
If we are in an 3D space then $dr = (dx,dy,dz)$.</p>

<p>Since $\nabla f$ is a vector that point to the steepest increase of the function.</p>

<p>If the displacement is towards the vector $\nabla f$ then df is going to be bigger, while if the displacement is in the opposite direction the change of the function is going to be little.
If the displacement is orthogonal to the $\nabla f$ vector, there is going to be no change in the the function, this is for the definition of dot product.</p>

<p>The gradient for a scalar function at a point $p$ is defined as:</p>

\[\large {\displaystyle \nabla f(p)={\begin{bmatrix}{\frac {\partial f}{\partial x_{1}}}(p)\\\vdots \\{\frac {\partial f}{\partial x_{n}}}(p)\end{bmatrix}}}

\tag{13}\]

<p>This definition works only if the function is differentiable in p, otherwise obviously we cannot do the partial derivates.</p>

<p>By the definition of gradient follows that if we want to minimize our scalar function, that quantifies how far the model’s prediction $h(x)$ is from the true output $y$ for a <strong>single data point</strong>, then we have to move in the opposite direction of the gradient from that point $\large p$.</p>

<p>The update rule for the gradient descend is:</p>

\[\large a_{n+1} = a_{n} - \eta\nabla f(a_{n})\]

<p>$\large \eta$ is the learning rate, is represent how long is the step you are going to take towards the function local minimum, $\Large a_{n}$ is the point you are evaluating the gradient, from that point you move to the direction of the fastest decrease of the function.</p>

<p>How can we apply gradient descent to learn in a neural network? The idea is to use gradient descent to find the weights $\large w_{k}$ and biases $\large b_{l}$ which minimize the cost in Equation. To see how this works, let’s restate the gradient descent update rule, with the weights and biases replacing the variables $\large v_{j}$. In other words, our “position” now has components $\large w_{k}$ and $\large b_{l}$, and the gradient vector $\nabla C$ has corresponding components $\large \frac{\partial C}{\partial w_{k}}$ and $\large \frac{\partial C}{\partial b}$. Writing out the gradient descent update rule in terms of components, we have the update rule for the bias:
\(\large
 b_{1} \to b_{1}^{′} = b_{1} - \eta \frac{\partial C}{\partial b_{1}}
 \tag{14}\)</p>

<p>And the update rule for the weights of every single layer:</p>

\[\large w_{k} \to w_{k}^{′} = w_{k}-\eta \frac{\partial C}{\partial w_{k}}
\tag{15}\]

<p>By applying this rule we can “roll down the hill” and hopefully find a minimum of the cost function.
Of course we cannot be sure that the minimum we’ll find will be the global minimum of the function, but just a local minimum.
The lesson is that we cannot be sure if there is a better configuration of weights and biases that make our model predict better.</p>

<p>A better implementation of gradient descend is stochastic gradient descend, as show in the chapter of the cost function, we have defined a cost function with multiple sample.
The idea of stochastic gradient descend is to estimate the gradient $\nabla C$ by computing  $\nabla C_{x}$ for a small sample of randomly chosen training inputs. By averaging over this small sample it turns out that we can quickly get a good estimate of the true gradient $\nabla C$, and this helps speed up gradient descent, and thus learning.</p>

<p>We are calling those random input training samples $\large(X_{1},X_{2},\dots,X_{m} )$ we will call them <strong>mini-batch</strong>.
The $m$ must be large enough to have a roughly similar result for the gradient.
So that $\nabla C_{X_{j}}$ and $\nabla C_{X}$ will be almost the same, but the gradient will be much easier to compute.</p>

<p>If this is true so we have:</p>

\[\Large 

\frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_{X} \nabla C_{X}}{n} =\nabla_{} C\]

<p>Where the second sum is over <strong>all</strong> the set of training data, so we get the approximation used for stochastic gradient descend:</p>

\[\Large
\frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \nabla C\]

<p>Taking this into account the update rule for stochastic descend becomes:</p>

\[\large
w_k' = w_k - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k}

\tag{16}\]

\[\large

b_l' = b_l - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}
\tag{17}\]

<p>Let’s make a concrete example on how a neural network is trainer using stochastic gradient descend:</p>

<h3 id="start-of-training">Start of Training:</h3>

<ul>
  <li>Your model begins with <strong>random weights and biases</strong>.</li>
  <li>It doesn’t know anything yet — its predictions are probably <strong>garbage</strong>.
    <h3 id="epoch-1">Epoch 1:</h3>
  </li>
  <li><strong>Shuffle</strong> the full training set (e.g. 100,000 examples).</li>
  <li>Break it into <strong>mini-batches</strong> (e.g. 100,000 examples → 1,562 mini-batches of 64 examples).
    <h4 id="for-each-mini-batch">For each mini-batch:</h4>
  </li>
</ul>

<ol>
  <li><strong>Backpropagation step</strong>: compute the <strong>gradients</strong> $\large \to$ how much each weight and bias should change to reduce the error.</li>
  <li><strong>Update</strong> the weights and biases using the SGD formulas:
    <h3 id="epoch-2">Epoch 2:</h3>
  </li>
</ol>

<ul>
  <li><strong>Shuffle</strong> the data again (important to avoid fixed patterns).</li>
  <li>Repeat the mini-batch training process.</li>
  <li>Now, weights and biases are <strong>slightly better</strong>.</li>
  <li>The model should start making <strong>better predictions</strong>.
    <h3 id="repeat-for-many-epochs-eg-10-50-100">Repeat for Many Epochs (e.g., 10, 50, 100):</h3>
  </li>
  <li>With each epoch, the model sees <strong>all training examples again</strong> (in new order).</li>
  <li>Parameters are <strong>updated gradually</strong>.</li>
  <li>The <strong>cost function</strong> ( C ) (overall error) should <strong>decrease</strong> over time.</li>
  <li>The model becomes better at:
    <ul>
      <li><strong>Generalizing</strong></li>
      <li><strong>Predicting accurately</strong></li>
      <li><strong>Learning</strong> meaningful patterns</li>
    </ul>
  </li>
</ul>

<h2 id="algorithm-and-implementation">Algorithm and implementation</h2>

<p>The algorithm for backpropagation is composed of three phases:
1) Input a sample of training example
2) For each training sample:
1) Feedforward phase
2) Compute output error
3) Backpropagate the error
3) Gradient descend</p>

<h3 id="2-phase">2) phase</h3>

<p>We need to find the quantities $\large \frac{\partial C}{\partial w^l}$ and $\large \frac{\partial C}{\partial b^l}$ for all layers $l$.</p>

<p>So for each layer $l$ starting from the last one and moving backwards we have to compute first:</p>

\[\large \delta^L :=\frac{\partial C}{\partial a^L}\]

<p>And then propagate the error backwards:</p>

\[\large
\delta^l = \left( \frac{\partial a^{l+1}}{\partial a^l} \right)^\top \cdot \delta^{l+1}, \quad \text{for } l = L, L - 1, L - 2, \dots, 1

\tag{11}\]

<p>And for each layer compute what we are looking for as:</p>

\[\large \frac{\partial C}{\partial w^l} =  \frac{\partial a^l}{\partial w^l} \overset{i}{\cdot} \delta^l 
\tag{12}\]

<p>And:</p>

\[\large 
\frac{\partial C}{\partial b^l} = \delta^l\]

<h3 id="3-phase">3) phase</h3>
<p>Once computed these derivatives we have to use gradient descend as:</p>

\[\large
w_k' = w_k - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k}

\tag{16}\]

\[\large
b_l' = b_l - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}
\tag{17}\]

<p>This is the big summary of the backpropagation algorithm of his most general form, if we want to implement this algorithm we need to decide which activation function and cost function we are going to use.
We are going to use the sigmoid function:</p>

\[\large \sigma(x)=\frac{1}{1+e^{-x}},\quad \text{with} \quad \sigma^{′}(x)=\sigma(x)(1-\sigma(x))\]

<p>Meanwhile as cost function the squared error:</p>

\[\large
C = \frac{1}{2} \| a^L - y \|^2,\]

<p>I’m going to use the code of Micheal Nielsen you can find on his book, however you can find the complete code on my github page used with training samples and MINST dataset.</p>

<p>Before write the code we need to understand how the equations seen on phase 2 of the algorithm changes if we use the sigmoid function and the squared error as cost function.</p>

<p>We start computing $\large \delta^L$ the error for the last layer we defined as:</p>

\[\large \delta^L :=\frac{\partial C}{\partial a^L}\]

<p>Now if we take the derivative of the squared error with respect to $\large a^L$ we obtain (check for yourself):</p>

\[\large 
\frac{\partial C}{\partial a^L}=a^L-y\]

<p>the error term at the output layer is defined as
\(\large
\delta^L = \frac{\partial C}{\partial z^L}.\)</p>

<p>There is no contradiction in defining the output layer error as</p>

\[\large
\delta^L := \frac{\partial C}{\partial a^L},\]

<p>because this is a valid partial derivative that describes how the cost changes with respect to the activation at layer $\large L$. However, during backpropagation, we ultimately need the derivative with respect to $\large z^L$, since $\large z^L$depends directly on the weights. By applying the chain rule, we refine our expression:</p>

\[\large
\delta^L = \frac{\partial C}{\partial z^L} = \frac{\partial C}{\partial a^L} \odot \frac{\partial a^L}{\partial z^L}.\]

<p>Since we now that $\large \frac{\partial C}{\partial a^L} = a^L - y$, and we know the form of the derivative of the activation function:</p>

\[\large
\frac{\partial a^L}{\partial z^L} = \sigma'(z^L) = a^L \odot (1 - a^L),\]

<p>this leads us to the final expression for the error on the last layer.</p>

\[\large
\delta^L = (a^L - y) \odot a^L \odot (1 - a^L).\]

<p>Now we need to propagate the error back recursively using the rule:</p>

\[\large
\delta^l = \left( \frac{\partial a^{l+1}}{\partial a^l} \right)^\top \cdot \delta^{l+1}, \quad \text{for } l = L, L - 1, L - 2, \dots, 1

\tag{11}\]

<p><strong>What form does this take with the sigmoid activation function?</strong></p>

\[\large
\begin{align*}
a^{l+1} &amp;= \sigma(z^{l+1}) \\
        &amp;= \sigma(W^{l+1} a^l + b^{l+1}) \\
\\
\frac{\partial a^{l+1}}{\partial a^l} 
        &amp;= \frac{\partial \sigma(z^{l+1})}{\partial a^l} \\
        &amp;= \frac{\partial \sigma(z^{l+1})}{\partial z^{l+1}} \cdot \frac{\partial z^{l+1}}{\partial a^l}
\end{align*}\]

<p>In the last term I’ve just applied the chain rule.
We know:</p>

\[\large
z^{l+1} = W^{l+1} a^l + b^{l+1}\]

<p>Since this is a linear function of $\large a^l$, taking it’s derivative the second term of the last expression becomes:</p>

\[\large
\frac{\partial z^{l+1}}{\partial a^l} = W^{l+1}\]

<p>Activations are applied element by element:</p>

\[\large
a^{l+1} = \sigma(z^{l+1})\]

<p>So the derivative is a <strong>diagonal matrix</strong> with the derivative of $\large \sigma$ applied to each entry:</p>

\[\large
\frac{\partial \sigma(z^{l+1})}{\partial z^{l+1}} = \mathrm{diag}(\sigma'(z^{l+1}))\]

<p>This matrix has $\large \sigma’(z_i)$ on the diagonal and zeros elsewhere.
So adding all up together, the transpose becomes:</p>

\[\large
\left( \frac{\partial a^{l+1}}{\partial a^l} \right)^\top = \left(\mathrm{diag}(\sigma'(z^{l+1})) \cdot (W^{l+1})^\top \right)\]

<p>We have not finished yet, we have to multiply this by the error of $\large \delta^{l+1}=\frac{\partial C}{\partial a^{l+1}}$.
But multiplying a diagonal matrix by a vector is just an elementwise product!</p>

\[\large
\sigma'(z^{l+1}) \odot \left( (W^{l+1})^\top \cdot \frac{\partial C}{\partial a^{l+1}} \right)\]

<p>This gives us the clean recursive formula we love in backpropagation. So:</p>

\[\large
\delta^l = (W^{l+1})^\top \cdot \delta^{l+1} \odot \sigma'(z^l)\]

<p>That we can write also (remembering for form of the first derivative of the activation function):</p>

\[\large
\delta^l = (W^{l+1})^\top \cdot \delta^{l+1} \odot a^l \odot (1 - a^l)\]

<h3 id="gradient-of-the-weights">Gradient of the weights</h3>

<p>Once we have the error vector $\large \delta^l$, we can compute the gradient of the cost with respect to the weights:</p>

\[\large
\frac{\partial C}{\partial w^l} = \frac{\partial a^l}{\partial w^l} \overset{i}{\cdot} \delta^l\]

<p>Let’s examine a single element of this expression:</p>

\[\large
\frac{\partial a^l_i}{\partial w^l_{jk}} = \frac{\partial \sigma(z^l_i)}{\partial w^l_{jk}} = \sigma'(z^l_i) \cdot \frac{\partial z^l_i}{\partial w^l_{jk}}\]

<p>Since:</p>

\[\large
z^l_i = \sum_k w^l_{ik} a^{l-1}_k + b^l_i\]

<p>Then:</p>

\[\large
\frac{\partial z^l_i}{\partial w^l_{jk}} =
\begin{cases}
a^{l-1}_k &amp; \text{if } i = j \\
0 &amp; \text{otherwise}
\end{cases}\]

<p>So:</p>

\[\large
\frac{\partial a^l_j}{\partial w^l_{jk}} = \sigma'(z^l_j) \cdot a^{l-1}_k\]

<p>Multiplying by the error:</p>

\[\large
\frac{\partial C}{\partial w^l_{jk}} = \delta^l_j \cdot a^{l-1}_k\]

<p>Switching to matrix form the full gradient is given by:</p>

\[\large
\frac{\partial C}{\partial w^l} = \delta^l (a^{l-1})^\top\]

<p>This is the outer product between the error vector at layer $\large l$ and the activations from the previous layer.</p>

<h3 id="what-about-the-bias-large-bl">What about the bias $\large b^l$?</h3>

<p>The bias appears in the pre-activation like this:</p>

\[\large
z^l = W^l a^{l-1} + b^l\]

<p>So when we differentiate with respect to $\large b^l$, it’s even simpler.</p>

<p>We know:</p>

\[\large
a^l = \sigma(z^l) = \sigma(W^l a^{l-1} + b^l)\]

<p>This means the bias $\large b^l$ directly and linearly affects the pre-activation $\large z^l$.<br />
That is:</p>

\[\large
\frac{\partial z^l}{\partial b^l} = I\]

<p>(the identity matrix).</p>

<p>So, using the chain rule:</p>

\[\large
\frac{\partial C}{\partial b^l} =
\frac{\partial z^l}{\partial b^l} \cdot \frac{\partial C}{\partial z^l}
= I \cdot \delta^l = \delta^l\]

<p>The gradient of the cost with respect to the bias is simply the error vector:</p>

\[\large
\frac{\partial C}{\partial b^l} = \delta^l\]

<h2 id="conclusion">Conclusion</h2>
<h2 id="key-takeaway-from-general-backpropagation-to-implementation">Key Takeaway: From General Backpropagation to Implementation</h2>

<p>Starting from the most general backpropagation equations, we derived the specific forms used in practice, depending on the activation and cost functions chosen. Here is a concise summary of how the expressions evolve:</p>

<hr />

<h3 id="output-layer-error">Output Layer Error</h3>

\[\large
\delta^L := \frac{\partial C}{\partial a^L} \quad \to \quad \delta^L = (a^L - y) \odot a^L \odot (1 - a^L)\]

<hr />

<h3 id="recursive-error-for-hidden-layers">Recursive Error for Hidden Layers</h3>

\[\large
\delta^l = \left( \frac{\partial a^{l+1}}{\partial a^l} \right)^\top \cdot \delta^{l+1} \quad \to \quad \delta^l = (W^{l+1})^\top \cdot \delta^{l+1} \odot a^l \odot (1 - a^l)\]

<hr />

<h3 id="gradient-of-weights">Gradient of Weights</h3>

\[\large
\frac{\partial C}{\partial w^l} = \frac{\partial a^l}{\partial w^l} \overset{i}{\cdot} \delta^l \quad \to \quad \frac{\partial C}{\partial w^l} = \delta^l (a^{l-1})^\top\]

<hr />

<h3 id="gradient-of-biases">Gradient of Biases</h3>

\[\large
\frac{\partial C}{\partial b^l} = \delta^l\]

<hr />

<p>This summary highlights the transition from theoretical derivatives to practical formulas used in neural network training.</p>

<h1 id="implementation">Implementation</h1>

<p>Now we can finally dive into the implementation of these algorithm using the equations found above, you can find the complete code on my github page, indeed below you will find a brief explanation of the key concepts.</p>

<h3 id="setup">Setup</h3>

<p>We are going to setup the data structures used in the class, the methods <code class="language-plaintext highlighter-rouge">np.random,randn(x,y)</code> creates a structure of the shape indicated inside the parenthesis, created randomly.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
<span class="bp">self</span><span class="p">.</span><span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span>
<span class="bp">self</span><span class="p">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
<span class="bp">self</span><span class="p">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
</code></pre></div></div>

<p>The zip function connect two turples, for example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Simon"</span><span class="p">,</span> <span class="s">"Erik"</span><span class="p">]</span>
<span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">22</span><span class="p">]</span>
<span class="n">res</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="c1">#the result would be
</span><span class="o">--&gt;</span><span class="p">[(</span><span class="s">"Simon"</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="s">"Erik"</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span>
</code></pre></div></div>

<p>For the biases we are creating a matrix of dimentions $\large y \times 1$, we are not assigning it a simple vector because with a matrix will be simpler doing later operation, like calculating the activation of a neuron.</p>

<p>the code <code class="language-plaintext highlighter-rouge">sizes[1:]</code> is used to ignore the first layer (the input layer of the network), this is because we don’t want to assign biases this this layer.</p>

<p>In the <code class="language-plaintext highlighter-rouge">self.weights</code> part of code we are randomly assigning the weights of the network, the code <code class="language-plaintext highlighter-rouge">sizes[:-1], sizes[1:]</code> is used to take into account all the layers excluding the first and the last one.
If for example our <code class="language-plaintext highlighter-rouge">sizes</code> turple is <code class="language-plaintext highlighter-rouge">[1,2,1]</code> we would have two matrixes of dimentions: $\large 2 \times 1$ and $\large 1 \times 2$:</p>

\[\large
\begin{pmatrix}
w_{1,1}^1 \\
w_{2,1}^1
\end{pmatrix} \text{ and }

\begin{pmatrix}
w_{1,1}^2 w_{1,2}^2
\end{pmatrix}\]

<p>(remember the notation for weights of a network I’ve introduced at the beginning of this article).</p>

<p>This is just the introductory code, that set up in a random way the weights and biases of the network.</p>

<p>Then we have the main function of this algorithm <code class="language-plaintext highlighter-rouge">update_mini_batch</code>, is the function that update the weights and biases by applying gradient descend using backpropagation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mini_batch</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>


    <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">]</span>
    <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">]</span>

  

<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">mini_batch</span><span class="p">:</span>

    <span class="n">delta_nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_w</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">backprop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">nb</span><span class="o">+</span><span class="n">dnb</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dnb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_b</span><span class="p">)]</span>
    <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">nw</span><span class="o">+</span><span class="n">dnw</span> <span class="k">for</span> <span class="n">nw</span><span class="p">,</span> <span class="n">dnw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_w</span><span class="p">,</span> <span class="n">delta_nabla_w</span><span class="p">)]</span>

    <span class="bp">self</span><span class="p">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nw</span> 
                    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)]</span>

    <span class="bp">self</span><span class="p">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nb</span>

                    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">,</span> <span class="n">nabla_b</span><span class="p">)]</span>
</code></pre></div></div>

<p>The first two line are used to set up a data structure where the gradient for the biases and weights are going to be calculated, <code class="language-plaintext highlighter-rouge">np.zeros(b.shapes)</code> creates a numpy array of zeros with the shape of b.</p>

<p>The key part of this function is the loop, that for each value of the numpy array <code class="language-plaintext highlighter-rouge">mini_batch</code>, each item is composed of an input (x) and the expected output (y).</p>

<p>The most important line of code is <code class="language-plaintext highlighter-rouge">delta_nabla_b, delta_nabla_w = self.backprop(x, y)</code> because it calls the function backpropagation that gives back for each layer $l$:</p>

\[\delta\nabla b^l =\large \frac{\partial C}{\partial b^{l}}\]

<p>And</p>

\[\delta\nabla w^l =\large \frac{\partial C}{\partial w^{l}}\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">nb</span><span class="o">+</span><span class="n">dnb</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dnb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_b</span><span class="p">)]</span>
<span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">nw</span><span class="o">+</span><span class="n">dnw</span> <span class="k">for</span> <span class="n">nw</span><span class="p">,</span> <span class="n">dnw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_w</span><span class="p">,</span> <span class="n">delta_nabla_w</span><span class="p">)]</span>
</code></pre></div></div>

<p>Those two lines are used to <strong>accumulate the gradients</strong> (partial derivatives) for each layer in a neural network during <strong>mini-batch stochastic gradient descent (SGD)</strong>.</p>

<p>Then we can update the weights and biases according to the equations we have previously analized:</p>

\[\large
w_k' = w_k - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k}\]

\[\large
b_l' = b_l - \frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nw</span> 
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)]</span>

<span class="bp">self</span><span class="p">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nb</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">,</span> <span class="n">nabla_b</span><span class="p">)]</span>
</code></pre></div></div>

<p>Finally we are able to understand how this piece of code really work, and I’m going to explain in detail.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">backprop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

    <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">]</span>
    <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">]</span>

    <span class="c1"># feedforward
</span>    <span class="n">activation</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1"># list to store all the activations, layer by layer
</span>    <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list to store all the z vectors, layer by layer
</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span><span class="o">+</span><span class="n">b</span>
        <span class="n">zs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">activations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>

<span class="c1"># backward pass
</span>    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cost_derivative</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
    <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">].</span><span class="n">transpose</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_layers</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span>
        <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">transpose</span><span class="p">())</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)</span>
</code></pre></div></div>

<p>These first two lines as in the update_mini_batch function are used to set up the shape of the the numpy array that we are going to return at the end of the function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">]</span>
<span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">]</span>
</code></pre></div></div>

<p>The next piece of code is the feedforward phase, a key part of the process, we need to know the activation of every single layer if we want to backpropagate the error.
Remember from before how we defined the activation for a layer $\large \ell$.</p>

\[\large a^{\ell}=\sigma\left( W^{\ell}a^{\ell-1} + b^{\ell} \right)\]

<p>The input x stores the activation of the <strong>first layer of the network</strong> while the activation array is going to store all the activations arrays of the network.
Remember also how we defined the middle quantity $\large z$:</p>

\[\large z^{\ell} = W^{\ell}a^{\ell-1} + b^{\ell}\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># feedforward
</span>    <span class="n">activation</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1"># list to store all the activations, layer by layer
</span>    <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list to store all the z vectors, layer by layer
</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">biases</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span><span class="o">+</span><span class="n">b</span>
        <span class="n">zs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">activations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
</code></pre></div></div>

<p>Remembering that it’s easy to understand what this code is actually doing, is just applying the dot product between matrixes and adding the bias, and applying the activation function.</p>

<p>Here comes the key part of the algorithm, how do we write the code for a backward pass?
First of all remember we need the compute the error of the last layer as:</p>

\[\large
\delta^L = (a^L - y) \odot a^L \odot (1 - a^L)\]

<p>And we compute also the partial derivative for the weights and biases for the last layer.
\(\large
\frac{\partial C}{\partial w^L} = \delta^L (a^{L-1})^\top\)</p>

\[\large
\frac{\partial C}{\partial b^L} = \delta^L\]

<p>Then we repeat this for all the layers until the first one, we compute the activation of the layer, calculate the error thank to the backpropagation equation:</p>

\[\large
\delta^l = (W^{l+1})^\top \cdot \delta^{l+1} \odot a^l \odot (1 - a^l)\]

<p>And compute again the gradient of weights and biases, we’ll stop until we have reached the first layer and return the result.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># backward pass
</span>    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cost_derivative</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
    <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">].</span><span class="n">transpose</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_layers</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">weights</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span>
        <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">transpose</span><span class="p">())</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://neuralnetworksanddeeplearning.com/">Neural Networks and Deep Learning – Michael Nielsen</a></li>
  <li><a href="https://cs231n.github.io/optimization-2/">CS231n: Convolutional Neural Networks for Visual Recognition</a></li>
  <li><a href="https://www.deeplearningbook.org/">Deep Learning Book – Ian Goodfellow, Yoshua Bengio, Aaron Courville (MIT Press)</a></li>
  <li><a href="https://medium.com/data-science/backpropagation-step-by-step-derivation-99ac8fbdcc28">Medium-Step-By-Step Derivation</a></li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#images" class="page__taxonomy-item p-category" rel="tag">images</a><span class="sep">, </span>
    
      <a href="/tags/#jekyll" class="page__taxonomy-item p-category" rel="tag">jekyll</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#blog" class="page__taxonomy-item p-category" rel="tag">blog</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-08-02T00:00:00+02:00">August 2, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/blog/2025/10/03/PageRank.html" class="pagination--pager" title="PageRank">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">You May Also Enjoy</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/blog/2025/10/03/PageRank.html" rel="permalink">PageRank
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-10-03T00:00:00+02:00">October 3, 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">The pipeline for training a Graph Neural Network can be schematized as follows:
Input graph → Structural features → Learning algorithm → Prediction
One of th...</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://www.linkedin.com/in/simone-piccinini-b32966261/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://github.com/laurburke" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000"></a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    }
  };
</script>

<script async id="MathJax-script"
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  </body>
</html>
